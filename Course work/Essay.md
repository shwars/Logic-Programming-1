# Реферат
## по курсу "Логическое программирование"

### студент: Медведев Д.А.

## ТЕМА Сравнение реализации алгоритмов поиска на логических и императивных языках

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

# Введение

Каждый человек, который знаком с программированием, сталкивался с задачами, которые прекрасно решаются итеративно, то есть нужно написать 
какой-нибудь цикл. Например, пройтись по массиву и найти максимальный элемент. Итеративность, последовательность действий, циклы, условия 
являются флагманами императивного программирования. Также существуют задачи, в которых рекурсия является неплохим решением. Например, 
подсчет факториала. Но, чтобы реализовать рекурсию на обычном императивном языке, нужно использовать функции. А что если бы вся программа 
состояла из функций? Такое уже есть. Эта парадигма называется аппликативной (функциональной). Языки функционального программирования – 
Haskell, F#, Lisp. Алгоритмической моделью функционального программирования является лямбда-исчисление. Теперь немного поменяем наши функции.
Напишем некий набор фактов и правил, которые смогут полностью заменить функции. Данная парадигма называется декларативной (логической). 
Далее рассмотрим императивную и логическую парадигмы поближе и сравним реализацию алгоритмов поиска на них.


# Императивное программирование

Данная парадигма является самой распространенной парадигмой в программировании. Это неудивительно, так как языков императивного 
программирования больше, чем, к примеру, языков логического программирования. Языки императивного программирования: C/C++, Java, C#, 
Python, Go, JavaScript и многие другие. Также эти языки легче в изучении, понимании, продуктивнее в промышленном коде из-за своей прямой 
связи с компьютером, легче поддерживаемые (support) и прочее. Императивная парадигма основывается на алгоритмической модели – машине фон 
Неймана, которая в свою очередь базируется на математической модели – машине Тьюринга. Смысл машины Тьюринга состоит в том, что существует 
некая лента, бесконечная с одного конца, и на ней пишутся какие-либо символы с помощью управляющего устройства – головки записи-чтения, 
способной находится в одном из множества состояний, выполняются различные операции. Эта модель была придумана Аланом Тьюрингом в 1936 годом. 
На этом принципе основываются современные компьютеры.  Но, несмотря на то, что императивная парадигма ближе всех к устройству компьютера, 
у неё есть некоторые недостатки. К примеру, в императивных языках присутствует область видимости переменных, то есть если мы создаём 
переменную в функции, то мы не можем её использовать в основной программе (кроме случая, когда мы её возвращаем, но это немного другое). 
Также в достаточно популярном сегодня языке программирования Python все структуры данных являются объектами. Это значит, что если мы 
присваиваем один массив другому, то мы автоматически присваиваем кусок памяти, принадлежащий этому массиву, другому массиву.


Пример:
```python 
>>> a = [1] 
>>> b = a
>>> b.append(2)  #  добавляем двойку в массив
>>> a
[1, 2]
>>> b
[1, 2]
```


Всё это объясняется тем, что сами классы в Python, который ещё содержит в себе ООП парадигму, тоже являются объектами. Иногда это может 
вызывать проблемы, которых не бывает в языках логического программирования. Ещё чтобы решить какую-нибудь практическую задачу, нужно 
составить алгоритм её решения, иногда опираясь на особенности конкретного языка императивного программирования, а они бывают компилируемые 
и интерпретируемые, со строгой типизацией и динамические и прочие характеристики. Сам процесс составления определенного алгоритма по 
техническому заданию (ТЗ) или по словам человека, который чаще всего далёк от программирования, является достаточно сложным и творческим.


# Логическое программирование

Когда компьютеры стали обычным повседневным инструментом для людей, тогда возникла мысль, а почему бы не генерировать алгоритмы решения 
задач с их помощью. Так появилось декларативное (логическое) программирование. В основе логического программирования лежит алгоритмическая 
модель – логика предикатов первого порядка. Идеальной программой с точки зрения логической парадигмы является программа, эквивалентная 
описанию поставленной задачи на языке логики предикатов. Самыми распространенными языками логического программирования являются Prolog 
(programming in logic) и Mercury. Первым языком логического программирования был Planner, который использовался для экономии вычислительных 
ресурсов компьютеров с помощью бэктрекинга (отката назад). Суть логических языков программирования – перебор всех вариантов для поиска 
ответа на поставленную задачу. Для этого составляется дерево решений, используется упомянутый выше бэктрекинг, унификация (сопоставление 
конкретного значения переменной). Программа на логическом языке программирования представляет собой набор фактов и правил, которые образуют 
предикаты (привет, логика предикатов). Ниже представлена программа на Prolog, которая находит n-ое число Фибоначчи, считая первым числом 
ноль. С помощью данной программы и описания взаимодействия с ней можно понять, как работать с языком логического программирования Prolog.


```prolog
fib(1, 0).
fib(2, 1).
fib(N, Res) :- N > 1, N1 is N - 1, N2 is N - 2, fib(N1, Res1), fib(N2, Res2), Res is Res1 + Res2.
```


Программа очень напоминает рекурсивное вычисление чисел Фибоначчи на императивных языках. Здесь используется нисходящая рекурсия. 
Когда мы дойдем до фактов, мы начнем возвращаться из рекурсии и получим Res, который складывался из предыдущих рекурсивных вызовов. 
Далее попробуем запустить программу и спросить у неё, какое число Фибоначчи является четвёртым. Ожидаемый ответ – 2 (0, 1, 1, 2 …).


```prolog
?- fib(4, Num).
Num = 2 ;
false.
```


Получили правильный ответ, с помощью точки с запятой попросили еще варианты ответа, но их больше нет по понятной причине. 
В целом, логическая парадигма даёт нам почти всегда маленький по объёму код для решения задач, на которые ушло бы намного большее 
количество строчек на любом императивном языке. Более того в языках логического программирования не нужно присваивать что-то переменным 
для поиска результата, что является неотъемлемой частью императивной парадигмы. Но языки логического программирования работают медленнее 
императивных из-за полного перебора, который они совершают в поиске решения. Это является весомой причиной того, почему их редко используют.


# Алгоритмы поиска в графе

Издавна перед человечеством стояла задача, как можно быстрее добраться из пункта A в пункт B. Применялись различные методы. Например, 
факт того, что длина гипотенузы меньше длины суммы катетов в прямоугольном треугольнике используется порой и в наши дни. Но время шло, 
росло население Земли, следовательно, росло и количество городов на карте. Люди же ещё являются биосоциальными существами, и им нужно 
взаимодействовать друг с другом, так уж мы устроены. Так как все люди не могли жить рядом друг с другом, то приходилось проходить 
значительные расстояние, чтобы продать товар, поговорить с другом, навестить родственников и другое. В наше время расстояния между городами 
достаточно большие, и добраться в другой город иногда занимает приличное количество времени. Допустим, что типичному москвичу нужно 
добраться в какой-нибудь нетривиальный город, до которого добираться нужно не только по одной трассе, но и по проселочным дорогам, и 
другим трассам, и через другие города. Так как он москвич, то ему проще добраться на машине. Игнорируя всякие задержки (заправка, туалет и 
др.), мы можем рассчитать дорогу по времени, зная среднюю скорость и совокупную длину трасс. Но так как путь не один (город нетривиально
расположен к Москве), а средняя скорость будет приблизительно одинаковой (основной путь - трасса), то нам нужно выбрать путь с наименьшим 
расстоянием от Москвы до нужного города. Из городов и расстояний между ними можно составить некую структуру данных, в которой вершинами 
будут города, а ребрами будут расстояния между ними. Такая структура данных называется взвешенным, неориентированным (если мы не задаём 
направления дорог) графом. Также есть алгоритм решения данной задачи, который используется в современных навигаторах – алгоритм Дейкстры.
А теперь представим, что дороги не имеют длины, абстрагируемся от реального мира. Будем мерить путь в ребрах. Чем больше путь, тем больше 
ребер. В этом случае нам пригодятся алгоритмы поиска в ширину и в глубину. Поиск в глубину стремится сразу дойти до крайней (конечных) 
точки графа, из которой нет путей никуда. После этого он начинает рекурсивно возвращаться. Получается, что мы можем обойти весь граф и 
по пути считать, сколько ребер или вершин прошли из начальной точки. Поиск в ширину смотрит на вершины, которые являются соседними к 
текущей вершине и проходится по ним, выполняя такие же действия. Так мы тоже сможем обойти весь граф, но этот вид поиск позволит нам 
дать более определенное представление о графе, например, его классификацию по уровням. В принципе, поиск в глубину тоже может дать 
такую информацию, если его реализовать не рекурсивно, а с помощью стека. Поиск в ширину может выполняться на поле, 
чтобы, к примеру, найти выход из лабиринта, помогает в поиске компонент связности, находит кратчайший цикл в ориентированном взвешенном 
графе и прочее. Поиск в глубину применяется в топологической сортировке, поиске цикла, для поиска точек сочленения, мостов. Сложность 
алгоритмов поиска O(V + E), где V – количество вершин, Е – число ребер. 



# Алгоритмы поиска на императивных языках


Реализация поиска в глубину на Python:


```python
n, m = map(int, input().split()) # n – количество вершин, m – количество рёбер
G = [[] for i in range(n)] # G - граф
for i in range(m):
    a, b = map(int, input().split())
    a -= 1 # перевод вершин в 0-индексацию
    b -= 1
    G[a].append(b)
def dfs(start, used): # start – вершина, с которой мы начинаем; used – массив типа
                # bool, чтобы понимать, какие вершины мы посетили 
    used[start] = True
    for v in G[start]:
        if not used[v]:
            dfs(v, used)
```


Есть 2 способа представления графа в императивных языках. В виде матрицы смежности и списка смежности. Матрица смежности в среднем 
потребляет больше памяти особенно на разреженных графах, но на плотных графах, где между всеми вершинами есть ребра, этот вид хранения 
выглядит неплохим вариантом. Список смежности применяется на разреженных графах, где мало ребер. В программе выше граф задаётся списком 
смежности. Поиск осуществляется очень просто. Отмечаем, что посетили стартовую вершину и проходим по всем вершинам, которые связаны с ней 
ребром. Если вершина не посещена, то запускаем рекурсию от неё. Получается, что если нам надо найти какую-то определенную вершину, то 
длительность поиска зависит от того порядка, в котором задавался граф, как и в поиске в ширину. 

Реализация поиска в ширину на C++:


```c++
void bfs(int st, const vector<vector<int> >& graph, vector<int>& dist, vector<int>& path) {
  dist.assign(graph.size(), -1);
  queue<int> q;
  q.push(st);
  dist[st] = 0;
  while (!q.empty()) {
    int v = q.front();
    q.pop();
    for (int to : graph[v]) {
      if (dist[to] != -1) {
        continue;
      }
      path[to] = v; // определяем из какой вершины пришли
      dist[to] = dist[v] + 1; // определяем через сколько вершин прошли
      q.push(to);
    }
  }

}
```


Здесь граф тоже задаётся списком смежности. Сам алгоритм поиска в ширину осуществляется с помощью очереди. Создаём очередь, 
добавляем в неё стартовую вершину, запускаем цикл, пока очередь не опустеет, будем добавлять в неё вершины, которые связаны с текущей, 
и далее от каждой вершины в очереди будем делать то же самое. Попутно можно посчитать нужные характеристики.


# Алгоритмы поиска на Prolog


Поиск в глубину:

```prolog
path(X, Y, P) :- path1[[X], Y, P].
prolong([X | T], [Y, X | T]) :- move(X, Y), not(member(Y, [X | T])).
path1([X | T], X, [X | T]).
path1(P, Y, R) :- prolong(P, P1), path1(P1, Y, R). 
```


Поиск в глубину осуществляется похожим образом с императивными языками: начинаем двигаться из начальной вершины, пока не упремся в 
тупик или не найдем нужную вершину. При первом варианте делаем бэктрекинг. Предикат move позволяет нам сделать шаг к доступной вершине 
графа. Предикат prolong отвечает за продлевание пути с предотвращением зацикливания. Путь будет найден в обратном порядке. 


Поиск в ширину:

```prolog
path(X, Y, P) :- bdth([[X]], Y, P). 
bdth([[X | T] | _], X, [X | T]).
bdth([P, QI], X, R) :- findall(Z, prolong(P, Z), T), append(QI, T, QO), !, bdth(QO, X, R).
bdth([_ | T], Y, L) :- bdth(T, Y, L). % удаляем непродляемый путь
```

Суть поиска в ширину такой же как и в императивных языках. Хотел отметить, что когда мы продлеваем первый путь в очереди, мы 
используем хвостовую рекурсию. 


# Сравнение поиска в ширину и глубину на Prolog


Чтобы сразу найти кратчайший путь, нужно использовать поиск в ширину, но в то же время он затрачивает больше памяти, чем поиск в глубину. 
Также поиск в ширину может использоваться для нахождения пути с циклами, в отличие от поиска в глубину. 


# Поиск с итерационным заглублением на Prolog


Этот поиск объединяет лучшие качества поисков в ширину и в глубину, так как его первое решение - кратчайший путь и затрачивается памяти 
как в поиске в глубину.

Реализация:


```prolog
search_id(S, F, P) :- num(Lvl), search_id(S, F, P, Lvl).   
search_id(S, F, P, D) :- depth_id([S], F, P, D).
depth_id([F | T], F, [F | T], _).
depth_id(P, F, R, N) :- N > 0, prolong(P, NP), N1 is N – 1, depth_id(NP, F, R, N1).
num(1).
num(A) :- num(B), A is B + 1.
```


Здесь мы просто заглубляемся внутрь по уровням и ищем нужный путь. Предикат num используется для получения бесконечного множества 
целых чисел, начиная с 1.  


# Заключение

Таким образом, я реализовал основные алгоритмы поиска на императивных и логических языках. По коду видно, что алгоритмы на императивных 
языках более читабельные и понятные. Но в то же время алгоритмы на Prolog смотрятся элегантнее и компактнее. Только Python может 
конкурировать с Prolog в этом плане. Идеи алгоритмов поиска во всех парадигмах одинаковые, реализация разная из-за устройства языков и 
их синтаксиса. Лично я выбрал бы императивные языки из-за того, что больше людей “говорят” на этих языках (то есть могут понимать код). 


# Список источников

1) Д.В. Сошников "Парадигма логического программирования"
2) Логическое программирование на Prolog https://habr.com/ru/post/552318/
3) Dfs, bfs https://habr.com/ru/post/504374/ 

